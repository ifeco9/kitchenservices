"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/auth/signin/page",{

/***/ "(app-pages-browser)/./src/services/profileService.ts":
/*!****************************************!*\
  !*** ./src/services/profileService.ts ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   profileService: function() { return /* binding */ profileService; }\n/* harmony export */ });\n/* harmony import */ var _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/supabaseClient */ \"(app-pages-browser)/./src/lib/supabaseClient.ts\");\n\nconst profileService = {\n    async getProfile (userId) {\n        const { data, error } = await _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"profiles\").select(\"*\").eq(\"id\", userId).maybeSingle();\n        if (error) throw error;\n        return data;\n    },\n    async updateProfile (userId, updates) {\n        const { data, error } = await _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"profiles\").update(updates).eq(\"id\", userId).select().maybeSingle();\n        if (error) throw error;\n        if (!data) {\n            // Profile doesn't exist, create it\n            const { data: { user } } = await _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_0__.supabase.auth.getUser();\n            if (!user) throw new Error(\"No authenticated user found\");\n            const { data: newProfile, error: insertError } = await _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"profiles\").insert({\n                id: userId,\n                email: user.email,\n                full_name: user.user_metadata.full_name || \"\",\n                role: \"customer\",\n                ...updates\n            }).select().single();\n            if (insertError) throw insertError;\n            return newProfile;\n        }\n        return data;\n    },\n    async updateCustomerProfile (userId, customerData) {\n        const { data, error } = await _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"profiles\").update({\n            phone: customerData.phone,\n            address: customerData.address,\n            city: customerData.city,\n            postcode: customerData.postcode,\n            preferred_contact: customerData.preferred_contact || \"email\",\n            updated_at: new Date().toISOString()\n        }).eq(\"id\", userId).select().single();\n        if (error) throw error;\n        return data;\n    },\n    async getTechnicianProfile (userId) {\n        const { data, error } = await _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"technicians\") // Query the specific table\n        .select(\"\\n        *,\\n        profiles:id (*)\\n      \") // Join with profiles linked by ID\n        .eq(\"id\", userId).single();\n        if (error) throw error;\n        // Flatten the response to match the Technician interface\n        // data.profiles is an object (single relation) because relation is 1:1 on id\n        const profile = data.profiles;\n        const { profiles, ...techData } = data;\n        return {\n            ...profile,\n            ...techData\n        };\n    },\n    async createTechnicianProfile (userId, initialData) {\n        const { data, error } = await _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"technicians\").insert({\n            id: userId,\n            ...initialData\n        }).select().single();\n        if (error) throw error;\n        return data;\n    },\n    async getTechnicians (limit) {\n        let query = _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"technicians\").select(\"\\n                *,\\n                profiles!technicians_id_fkey (full_name, avatar_url)\\n            \").eq(\"is_verified\", true).eq(\"availability_status\", \"available\");\n        if (limit) {\n            query = query.limit(limit);\n        }\n        const { data, error } = await query;\n        if (error) throw error;\n        return data.map((tech)=>({\n                ...tech,\n                ...tech.profiles // Flatten profile data\n            }));\n    },\n    async getPendingTechnicians () {\n        const { data, error } = await _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"technicians\").select(\"\\n                *,\\n                profiles!technicians_id_fkey (full_name, avatar_url, email)\\n            \").eq(\"is_verified\", false);\n        if (error) throw error;\n        return data.map((tech)=>({\n                ...tech,\n                ...tech.profiles\n            }));\n    },\n    async getTechniciansByService (serviceId) {\n        // Use !inner to filter technicians who have this service\n        // and where is_active is true\n        const { data, error } = await _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"technicians\").select(\"\\n                *,\\n                profiles!technicians_id_fkey (full_name, avatar_url),\\n                technician_services!inner(service_id, custom_price, is_active)\\n            \").eq(\"is_verified\", true).eq(\"availability_status\", \"available\").eq(\"technician_services.service_id\", serviceId).eq(\"technician_services.is_active\", true);\n        if (error) throw error;\n        return data.map((tech)=>{\n            // Flatten and include custom price if needed\n            const techService = tech.technician_services[0];\n            return {\n                ...tech,\n                ...tech.profiles,\n                // We could override hourly_rate with custom_price here if we wanted, \n                // but let's keep base rate for now or handle it in UI.\n                // Or maybe attach it?\n                service_price: techService === null || techService === void 0 ? void 0 : techService.custom_price\n            };\n        });\n    },\n    // Haversine formula to calculate distance between two points\n    calculateDistance (lat1, lon1, lat2, lon2) {\n        const R = 3959; // Earth's radius in miles\n        const dLat = (lat2 - lat1) * Math.PI / 180;\n        const dLon = (lon2 - lon1) * Math.PI / 180;\n        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.sin(dLon / 2) * Math.sin(dLon / 2);\n        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n        return R * c;\n    },\n    async getTechniciansByLocation (customerLat, customerLng, limit) {\n        // Fetch all verified and available technicians with location data\n        const { data, error } = await _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"technicians\").select(\"\\n                *,\\n                profiles:id (full_name, avatar_url)\\n            \");\n        if (error) throw error;\n        // Calculate distance and filter by service radius\n        const techniciansWithDistance = data.map((tech)=>{\n            const distance = this.calculateDistance(customerLat, customerLng, tech.location_lat || 0, tech.location_lng || 0);\n            return {\n                ...tech,\n                ...tech.profiles,\n                distance: Math.round(distance * 10) / 10 // Round to 1 decimal\n            };\n        }).filter((tech)=>tech.distance <= tech.service_radius_miles).sort((a, b)=>a.distance - b.distance);\n        if (limit) {\n            return techniciansWithDistance.slice(0, limit);\n        }\n        return techniciansWithDistance;\n    },\n    async getAllUsers () {\n        const { data, error } = await _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"profiles\").select(\"*\").order(\"created_at\", {\n            ascending: false\n        });\n        if (error) throw error;\n        return data;\n    },\n    async getUserStats () {\n        // Get total users\n        const { count: totalUsers, error: usersError } = await _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"profiles\").select(\"*\", {\n            count: \"exact\",\n            head: true\n        });\n        // Get total technicians\n        const { count: totalTechnicians, error: techError } = await _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"technicians\").select(\"*\", {\n            count: \"exact\",\n            head: true\n        });\n        // Get pending technicians\n        const { count: pendingTechnicians, error: pendingError } = await _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"technicians\").select(\"*\", {\n            count: \"exact\",\n            head: true\n        }).eq(\"is_verified\", false);\n        // Get total bookings\n        const { count: totalBookings, error: bookingsError } = await _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"bookings\").select(\"*\", {\n            count: \"exact\",\n            head: true\n        });\n        if (usersError || techError || pendingError || bookingsError) {\n            throw usersError || techError || pendingError || bookingsError;\n        }\n        return {\n            totalUsers: totalUsers || 0,\n            totalTechnicians: totalTechnicians || 0,\n            pendingTechnicians: pendingTechnicians || 0,\n            totalBookings: totalBookings || 0\n        };\n    },\n    async verifyTechnician (technicianId) {\n        const { data, error } = await _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"technicians\").update({\n            is_verified: true,\n            availability_status: \"available\"\n        }).eq(\"id\", technicianId).select().single();\n        if (error) throw error;\n        return data;\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy9wcm9maWxlU2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7OztBQUFnRDtBQUd6QyxNQUFNQyxpQkFBaUI7SUFDMUIsTUFBTUMsWUFBV0MsTUFBYztRQUMzQixNQUFNLEVBQUVDLElBQUksRUFBRUMsS0FBSyxFQUFFLEdBQUcsTUFBTUwseURBQVFBLENBQ2pDTSxJQUFJLENBQUMsWUFDTEMsTUFBTSxDQUFDLEtBQ1BDLEVBQUUsQ0FBQyxNQUFNTCxRQUNUTSxXQUFXO1FBRWhCLElBQUlKLE9BQU8sTUFBTUE7UUFDakIsT0FBT0Q7SUFDWDtJQUVBLE1BQU1NLGVBQWNQLE1BQWMsRUFBRVEsT0FBeUI7UUFDekQsTUFBTSxFQUFFUCxJQUFJLEVBQUVDLEtBQUssRUFBRSxHQUFHLE1BQU1MLHlEQUFRQSxDQUNqQ00sSUFBSSxDQUFDLFlBQ0xNLE1BQU0sQ0FBQ0QsU0FDUEgsRUFBRSxDQUFDLE1BQU1MLFFBQ1RJLE1BQU0sR0FDTkUsV0FBVztRQUVoQixJQUFJSixPQUFPLE1BQU1BO1FBRWpCLElBQUksQ0FBQ0QsTUFBTTtZQUNQLG1DQUFtQztZQUNuQyxNQUFNLEVBQUVBLE1BQU0sRUFBRVMsSUFBSSxFQUFFLEVBQUUsR0FBRyxNQUFNYix5REFBUUEsQ0FBQ2MsSUFBSSxDQUFDQyxPQUFPO1lBQ3RELElBQUksQ0FBQ0YsTUFBTSxNQUFNLElBQUlHLE1BQU07WUFFM0IsTUFBTSxFQUFFWixNQUFNYSxVQUFVLEVBQUVaLE9BQU9hLFdBQVcsRUFBRSxHQUFHLE1BQU1sQix5REFBUUEsQ0FDMURNLElBQUksQ0FBQyxZQUNMYSxNQUFNLENBQUM7Z0JBQ0pDLElBQUlqQjtnQkFDSmtCLE9BQU9SLEtBQUtRLEtBQUs7Z0JBQ2pCQyxXQUFXVCxLQUFLVSxhQUFhLENBQUNELFNBQVMsSUFBSTtnQkFDM0NFLE1BQU07Z0JBQ04sR0FBR2IsT0FBTztZQUNkLEdBQ0NKLE1BQU0sR0FDTmtCLE1BQU07WUFFWCxJQUFJUCxh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QTtRQUNqQixPQUFPRDtJQUNYO0FBQ0osRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvc2VydmljZXMvcHJvZmlsZVNlcnZpY2UudHM/Mzg5OCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzdXBhYmFzZSB9IGZyb20gJ0AvbGliL3N1cGFiYXNlQ2xpZW50JztcclxuaW1wb3J0IHsgUHJvZmlsZSwgVGVjaG5pY2lhbiB9IGZyb20gJ0AvdHlwZXMnO1xyXG5cclxuZXhwb3J0IGNvbnN0IHByb2ZpbGVTZXJ2aWNlID0ge1xyXG4gICAgYXN5bmMgZ2V0UHJvZmlsZSh1c2VySWQ6IHN0cmluZyk6IFByb21pc2U8UHJvZmlsZSB8IG51bGw+IHtcclxuICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAgICAgICAuZnJvbSgncHJvZmlsZXMnKVxyXG4gICAgICAgICAgICAuc2VsZWN0KCcqJylcclxuICAgICAgICAgICAgLmVxKCdpZCcsIHVzZXJJZClcclxuICAgICAgICAgICAgLm1heWJlU2luZ2xlKCk7XHJcblxyXG4gICAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgcmV0dXJuIGRhdGEgYXMgUHJvZmlsZSB8IG51bGw7XHJcbiAgICB9LFxyXG5cclxuICAgIGFzeW5jIHVwZGF0ZVByb2ZpbGUodXNlcklkOiBzdHJpbmcsIHVwZGF0ZXM6IFBhcnRpYWw8UHJvZmlsZT4pIHtcclxuICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAgICAgICAuZnJvbSgncHJvZmlsZXMnKVxyXG4gICAgICAgICAgICAudXBkYXRlKHVwZGF0ZXMpXHJcbiAgICAgICAgICAgIC5lcSgnaWQnLCB1c2VySWQpXHJcbiAgICAgICAgICAgIC5zZWxlY3QoKVxyXG4gICAgICAgICAgICAubWF5YmVTaW5nbGUoKTtcclxuXHJcbiAgICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcclxuXHJcbiAgICAgICAgaWYgKCFkYXRhKSB7XHJcbiAgICAgICAgICAgIC8vIFByb2ZpbGUgZG9lc24ndCBleGlzdCwgY3JlYXRlIGl0XHJcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogeyB1c2VyIH0gfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguZ2V0VXNlcigpO1xyXG4gICAgICAgICAgICBpZiAoIXVzZXIpIHRocm93IG5ldyBFcnJvcignTm8gYXV0aGVudGljYXRlZCB1c2VyIGZvdW5kJyk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCB7IGRhdGE6IG5ld1Byb2ZpbGUsIGVycm9yOiBpbnNlcnRFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAgICAgICAgIC5mcm9tKCdwcm9maWxlcycpXHJcbiAgICAgICAgICAgICAgICAuaW5zZXJ0KHtcclxuICAgICAgICAgICAgICAgICAgICBpZDogdXNlcklkLFxyXG4gICAgICAgICAgICAgICAgICAgIGVtYWlsOiB1c2VyLmVtYWlsISxcclxuICAgICAgICAgICAgICAgICAgICBmdWxsX25hbWU6IHVzZXIudXNlcl9tZXRhZGF0YS5mdWxsX25hbWUgfHwgJycsXHJcbiAgICAgICAgICAgICAgICAgICAgcm9sZTogJ2N1c3RvbWVyJywgLy8gRGVmYXVsdCByb2xlXHJcbiAgICAgICAgICAgICAgICAgICAgLi4udXBkYXRlc1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5zZWxlY3QoKVxyXG4gICAgICAgICAgICAgICAgLnNpbmdsZSgpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGluc2VydEVycm9yKSB0aHJvdyBpbnNlcnRFcnJvcjtcclxuICAgICAgICAgICAgcmV0dXJuIG5ld1Byb2ZpbGUgYXMgUHJvZmlsZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBkYXRhIGFzIFByb2ZpbGU7XHJcbiAgICB9LFxyXG5cclxuICAgIGFzeW5jIHVwZGF0ZUN1c3RvbWVyUHJvZmlsZSh1c2VySWQ6IHN0cmluZywgY3VzdG9tZXJEYXRhOiB7XHJcbiAgICAgICAgcGhvbmU/OiBzdHJpbmc7XHJcbiAgICAgICAgYWRkcmVzcz86IHN0cmluZztcclxuICAgICAgICBjaXR5Pzogc3RyaW5nO1xyXG4gICAgICAgIHBvc3Rjb2RlPzogc3RyaW5nO1xyXG4gICAgICAgIHByZWZlcnJlZF9jb250YWN0PzogJ2VtYWlsJyB8ICdwaG9uZSc7XHJcbiAgICB9KSB7XHJcbiAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAgICAgLmZyb20oJ3Byb2ZpbGVzJylcclxuICAgICAgICAgICAgLnVwZGF0ZSh7XHJcbiAgICAgICAgICAgICAgICBwaG9uZTogY3VzdG9tZXJEYXRhLnBob25lLFxyXG4gICAgICAgICAgICAgICAgYWRkcmVzczogY3VzdG9tZXJEYXRhLmFkZHJlc3MsXHJcbiAgICAgICAgICAgICAgICBjaXR5OiBjdXN0b21lckRhdGEuY2l0eSxcclxuICAgICAgICAgICAgICAgIHBvc3Rjb2RlOiBjdXN0b21lckRhdGEucG9zdGNvZGUsXHJcbiAgICAgICAgICAgICAgICBwcmVmZXJyZWRfY29udGFjdDogY3VzdG9tZXJEYXRhLnByZWZlcnJlZF9jb250YWN0IHx8ICdlbWFpbCcsXHJcbiAgICAgICAgICAgICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLmVxKCdpZCcsIHVzZXJJZClcclxuICAgICAgICAgICAgLnNlbGVjdCgpXHJcbiAgICAgICAgICAgIC5zaW5nbGUoKTtcclxuXHJcbiAgICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcclxuICAgICAgICByZXR1cm4gZGF0YSBhcyBQcm9maWxlO1xyXG4gICAgfSxcclxuXHJcbiAgICBhc3luYyBnZXRUZWNobmljaWFuUHJvZmlsZSh1c2VySWQ6IHN0cmluZykge1xyXG4gICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgICAgICAgIC5mcm9tKCd0ZWNobmljaWFucycpIC8vIFF1ZXJ5IHRoZSBzcGVjaWZpYyB0YWJsZVxyXG4gICAgICAgICAgICAuc2VsZWN0KGBcclxuICAgICAgICAqLFxyXG4gICAgICAgIHByb2ZpbGVzOmlkICgqKVxyXG4gICAgICBgKSAvLyBKb2luIHdpdGggcHJvZmlsZXMgbGlua2VkIGJ5IElEXHJcbiAgICAgICAgICAgIC5lcSgnaWQnLCB1c2VySWQpXHJcbiAgICAgICAgICAgIC5zaW5nbGUoKTtcclxuXHJcbiAgICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcclxuXHJcbiAgICAgICAgLy8gRmxhdHRlbiB0aGUgcmVzcG9uc2UgdG8gbWF0Y2ggdGhlIFRlY2huaWNpYW4gaW50ZXJmYWNlXHJcbiAgICAgICAgLy8gZGF0YS5wcm9maWxlcyBpcyBhbiBvYmplY3QgKHNpbmdsZSByZWxhdGlvbikgYmVjYXVzZSByZWxhdGlvbiBpcyAxOjEgb24gaWRcclxuICAgICAgICBjb25zdCBwcm9maWxlID0gZGF0YS5wcm9maWxlcyBhcyB1bmtub3duIGFzIFByb2ZpbGU7XHJcbiAgICAgICAgY29uc3QgeyBwcm9maWxlcywgLi4udGVjaERhdGEgfSA9IGRhdGE7XHJcblxyXG4gICAgICAgIHJldHVybiB7IC4uLnByb2ZpbGUsIC4uLnRlY2hEYXRhIH0gYXMgVGVjaG5pY2lhbjtcclxuICAgIH0sXHJcblxyXG4gICAgYXN5bmMgY3JlYXRlVGVjaG5pY2lhblByb2ZpbGUodXNlcklkOiBzdHJpbmcsIGluaXRpYWxEYXRhOiBQYXJ0aWFsPFRlY2huaWNpYW4+KSB7XHJcbiAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAgICAgLmZyb20oJ3RlY2huaWNpYW5zJylcclxuICAgICAgICAgICAgLmluc2VydCh7IGlkOiB1c2VySWQsIC4uLmluaXRpYWxEYXRhIH0pXHJcbiAgICAgICAgICAgIC5zZWxlY3QoKVxyXG4gICAgICAgICAgICAuc2luZ2xlKCk7XHJcblxyXG4gICAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9LFxyXG5cclxuICAgIGFzeW5jIGdldFRlY2huaWNpYW5zKGxpbWl0PzogbnVtYmVyKSB7XHJcbiAgICAgICAgbGV0IHF1ZXJ5ID0gc3VwYWJhc2VcclxuICAgICAgICAgICAgLmZyb20oJ3RlY2huaWNpYW5zJylcclxuICAgICAgICAgICAgLnNlbGVjdChgXHJcbiAgICAgICAgICAgICAgICAqLFxyXG4gICAgICAgICAgICAgICAgcHJvZmlsZXMhdGVjaG5pY2lhbnNfaWRfZmtleSAoZnVsbF9uYW1lLCBhdmF0YXJfdXJsKVxyXG4gICAgICAgICAgICBgKVxyXG4gICAgICAgICAgICAuZXEoJ2lzX3ZlcmlmaWVkJywgdHJ1ZSlcclxuICAgICAgICAgICAgLmVxKCdhdmFpbGFiaWxpdHlfc3RhdHVzJywgJ2F2YWlsYWJsZScpO1xyXG5cclxuICAgICAgICBpZiAobGltaXQpIHtcclxuICAgICAgICAgICAgcXVlcnkgPSBxdWVyeS5saW1pdChsaW1pdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBxdWVyeTtcclxuICAgICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xyXG5cclxuICAgICAgICByZXR1cm4gZGF0YS5tYXAoKHRlY2g6IGFueSkgPT4gKHtcclxuICAgICAgICAgICAgLi4udGVjaCxcclxuICAgICAgICAgICAgLi4udGVjaC5wcm9maWxlcyAvLyBGbGF0dGVuIHByb2ZpbGUgZGF0YVxyXG4gICAgICAgIH0pKSBhcyBUZWNobmljaWFuW107XHJcbiAgICB9LFxyXG5cclxuICAgIGFzeW5jIGdldFBlbmRpbmdUZWNobmljaWFucygpIHtcclxuICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAgICAgICAuZnJvbSgndGVjaG5pY2lhbnMnKVxyXG4gICAgICAgICAgICAuc2VsZWN0KGBcclxuICAgICAgICAgICAgICAgICosXHJcbiAgICAgICAgICAgICAgICBwcm9maWxlcyF0ZWNobmljaWFuc19pZF9ma2V5IChmdWxsX25hbWUsIGF2YXRhcl91cmwsIGVtYWlsKVxyXG4gICAgICAgICAgICBgKVxyXG4gICAgICAgICAgICAuZXEoJ2lzX3ZlcmlmaWVkJywgZmFsc2UpO1xyXG5cclxuICAgICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xyXG5cclxuICAgICAgICByZXR1cm4gZGF0YS5tYXAoKHRlY2g6IGFueSkgPT4gKHtcclxuICAgICAgICAgICAgLi4udGVjaCxcclxuICAgICAgICAgICAgLi4udGVjaC5wcm9maWxlc1xyXG4gICAgICAgIH0pKSBhcyBUZWNobmljaWFuW107XHJcbiAgICB9LFxyXG5cclxuICAgIGFzeW5jIGdldFRlY2huaWNpYW5zQnlTZXJ2aWNlKHNlcnZpY2VJZDogc3RyaW5nKSB7XHJcbiAgICAgICAgLy8gVXNlICFpbm5lciB0byBmaWx0ZXIgdGVjaG5pY2lhbnMgd2hvIGhhdmUgdGhpcyBzZXJ2aWNlXHJcbiAgICAgICAgLy8gYW5kIHdoZXJlIGlzX2FjdGl2ZSBpcyB0cnVlXHJcbiAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAgICAgLmZyb20oJ3RlY2huaWNpYW5zJylcclxuICAgICAgICAgICAgLnNlbGVjdChgXHJcbiAgICAgICAgICAgICAgICAqLFxyXG4gICAgICAgICAgICAgICAgcHJvZmlsZXMhdGVjaG5pY2lhbnNfaWRfZmtleSAoZnVsbF9uYW1lLCBhdmF0YXJfdXJsKSxcclxuICAgICAgICAgICAgICAgIHRlY2huaWNpYW5fc2VydmljZXMhaW5uZXIoc2VydmljZV9pZCwgY3VzdG9tX3ByaWNlLCBpc19hY3RpdmUpXHJcbiAgICAgICAgICAgIGApXHJcbiAgICAgICAgICAgIC5lcSgnaXNfdmVyaWZpZWQnLCB0cnVlKVxyXG4gICAgICAgICAgICAuZXEoJ2F2YWlsYWJpbGl0eV9zdGF0dXMnLCAnYXZhaWxhYmxlJylcclxuICAgICAgICAgICAgLmVxKCd0ZWNobmljaWFuX3NlcnZpY2VzLnNlcnZpY2VfaWQnLCBzZXJ2aWNlSWQpXHJcbiAgICAgICAgICAgIC5lcSgndGVjaG5pY2lhbl9zZXJ2aWNlcy5pc19hY3RpdmUnLCB0cnVlKTtcclxuXHJcbiAgICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcclxuXHJcbiAgICAgICAgcmV0dXJuIGRhdGEubWFwKCh0ZWNoOiBhbnkpID0+IHtcclxuICAgICAgICAgICAgLy8gRmxhdHRlbiBhbmQgaW5jbHVkZSBjdXN0b20gcHJpY2UgaWYgbmVlZGVkXHJcbiAgICAgICAgICAgIGNvbnN0IHRlY2hTZXJ2aWNlID0gdGVjaC50ZWNobmljaWFuX3NlcnZpY2VzWzBdO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgLi4udGVjaCxcclxuICAgICAgICAgICAgICAgIC4uLnRlY2gucHJvZmlsZXMsXHJcbiAgICAgICAgICAgICAgICAvLyBXZSBjb3VsZCBvdmVycmlkZSBob3VybHlfcmF0ZSB3aXRoIGN1c3RvbV9wcmljZSBoZXJlIGlmIHdlIHdhbnRlZCwgXHJcbiAgICAgICAgICAgICAgICAvLyBidXQgbGV0J3Mga2VlcCBiYXNlIHJhdGUgZm9yIG5vdyBvciBoYW5kbGUgaXQgaW4gVUkuXHJcbiAgICAgICAgICAgICAgICAvLyBPciBtYXliZSBhdHRhY2ggaXQ/XHJcbiAgICAgICAgICAgICAgICBzZXJ2aWNlX3ByaWNlOiB0ZWNoU2VydmljZT8uY3VzdG9tX3ByaWNlXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSkgYXMgKFRlY2huaWNpYW4gJiB7IHNlcnZpY2VfcHJpY2U/OiBudW1iZXIgfSlbXTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gSGF2ZXJzaW5lIGZvcm11bGEgdG8gY2FsY3VsYXRlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50c1xyXG4gICAgY2FsY3VsYXRlRGlzdGFuY2UobGF0MTogbnVtYmVyLCBsb24xOiBudW1iZXIsIGxhdDI6IG51bWJlciwgbG9uMjogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgICAgICBjb25zdCBSID0gMzk1OTsgLy8gRWFydGgncyByYWRpdXMgaW4gbWlsZXNcclxuICAgICAgICBjb25zdCBkTGF0ID0gKGxhdDIgLSBsYXQxKSAqIE1hdGguUEkgLyAxODA7XHJcbiAgICAgICAgY29uc3QgZExvbiA9IChsb24yIC0gbG9uMSkgKiBNYXRoLlBJIC8gMTgwO1xyXG4gICAgICAgIGNvbnN0IGEgPVxyXG4gICAgICAgICAgICBNYXRoLnNpbihkTGF0IC8gMikgKiBNYXRoLnNpbihkTGF0IC8gMikgK1xyXG4gICAgICAgICAgICBNYXRoLmNvcyhsYXQxICogTWF0aC5QSSAvIDE4MCkgKiBNYXRoLmNvcyhsYXQyICogTWF0aC5QSSAvIDE4MCkgKlxyXG4gICAgICAgICAgICBNYXRoLnNpbihkTG9uIC8gMikgKiBNYXRoLnNpbihkTG9uIC8gMik7XHJcbiAgICAgICAgY29uc3QgYyA9IDIgKiBNYXRoLmF0YW4yKE1hdGguc3FydChhKSwgTWF0aC5zcXJ0KDEgLSBhKSk7XHJcbiAgICAgICAgcmV0dXJuIFIgKiBjO1xyXG4gICAgfSxcclxuXHJcbiAgICBhc3luYyBnZXRUZWNobmljaWFuc0J5TG9jYXRpb24oY3VzdG9tZXJMYXQ6IG51bWJlciwgY3VzdG9tZXJMbmc6IG51bWJlciwgbGltaXQ/OiBudW1iZXIpIHtcclxuICAgICAgICAvLyBGZXRjaCBhbGwgdmVyaWZpZWQgYW5kIGF2YWlsYWJsZSB0ZWNobmljaWFucyB3aXRoIGxvY2F0aW9uIGRhdGFcclxuICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAgICAgICAuZnJvbSgndGVjaG5pY2lhbnMnKVxyXG4gICAgICAgICAgICAuc2VsZWN0KGBcclxuICAgICAgICAgICAgICAgICosXHJcbiAgICAgICAgICAgICAgICBwcm9maWxlczppZCAoZnVsbF9uYW1lLCBhdmF0YXJfdXJsKVxyXG4gICAgICAgICAgICBgKVxyXG4gICAgICAgICAgICAvLyAuZXEoJ2lzX3ZlcmlmaWVkJywgdHJ1ZSkgLy8gQ29tbWVudGVkIG91dCBmb3IgdGVzdGluZy9kZW1vIHB1cnBvc2VzXHJcbiAgICAgICAgICAgIC8vIC5lcSgnYXZhaWxhYmlsaXR5X3N0YXR1cycsICdhdmFpbGFibGUnKTtcclxuICAgICAgICAgICAgO1xyXG5cclxuICAgICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xyXG5cclxuICAgICAgICAvLyBDYWxjdWxhdGUgZGlzdGFuY2UgYW5kIGZpbHRlciBieSBzZXJ2aWNlIHJhZGl1c1xyXG4gICAgICAgIGNvbnN0IHRlY2huaWNpYW5zV2l0aERpc3RhbmNlID0gZGF0YVxyXG4gICAgICAgICAgICAubWFwKCh0ZWNoOiBhbnkpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRpc3RhbmNlID0gdGhpcy5jYWxjdWxhdGVEaXN0YW5jZShcclxuICAgICAgICAgICAgICAgICAgICBjdXN0b21lckxhdCxcclxuICAgICAgICAgICAgICAgICAgICBjdXN0b21lckxuZyxcclxuICAgICAgICAgICAgICAgICAgICB0ZWNoLmxvY2F0aW9uX2xhdCB8fCAwLCAvLyBIYW5kbGUgbWlzc2luZyBsb2NhdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIHRlY2gubG9jYXRpb25fbG5nIHx8IDBcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC4uLnRlY2gsXHJcbiAgICAgICAgICAgICAgICAgICAgLi4udGVjaC5wcm9maWxlcyxcclxuICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZTogTWF0aC5yb3VuZChkaXN0YW5jZSAqIDEwKSAvIDEwIC8vIFJvdW5kIHRvIDEgZGVjaW1hbFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLmZpbHRlcigodGVjaDogYW55KSA9PiB0ZWNoLmRpc3RhbmNlIDw9IHRlY2guc2VydmljZV9yYWRpdXNfbWlsZXMpXHJcbiAgICAgICAgICAgIC5zb3J0KChhOiBhbnksIGI6IGFueSkgPT4gYS5kaXN0YW5jZSAtIGIuZGlzdGFuY2UpO1xyXG5cclxuICAgICAgICBpZiAobGltaXQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRlY2huaWNpYW5zV2l0aERpc3RhbmNlLnNsaWNlKDAsIGxpbWl0KSBhcyBUZWNobmljaWFuW107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGVjaG5pY2lhbnNXaXRoRGlzdGFuY2UgYXMgVGVjaG5pY2lhbltdO1xyXG4gICAgfSxcclxuXHJcbiAgICBhc3luYyBnZXRBbGxVc2VycygpIHtcclxuICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAgICAgICAuZnJvbSgncHJvZmlsZXMnKVxyXG4gICAgICAgICAgICAuc2VsZWN0KCcqJylcclxuICAgICAgICAgICAgLm9yZGVyKCdjcmVhdGVkX2F0JywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pO1xyXG5cclxuICAgICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xyXG4gICAgICAgIHJldHVybiBkYXRhIGFzIFByb2ZpbGVbXTtcclxuICAgIH0sXHJcblxyXG4gICAgYXN5bmMgZ2V0VXNlclN0YXRzKCkge1xyXG4gICAgICAgIC8vIEdldCB0b3RhbCB1c2Vyc1xyXG4gICAgICAgIGNvbnN0IHsgY291bnQ6IHRvdGFsVXNlcnMsIGVycm9yOiB1c2Vyc0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAgICAgICAuZnJvbSgncHJvZmlsZXMnKVxyXG4gICAgICAgICAgICAuc2VsZWN0KCcqJywgeyBjb3VudDogJ2V4YWN0JywgaGVhZDogdHJ1ZSB9KTtcclxuXHJcbiAgICAgICAgLy8gR2V0IHRvdGFsIHRlY2huaWNpYW5zXHJcbiAgICAgICAgY29uc3QgeyBjb3VudDogdG90YWxUZWNobmljaWFucywgZXJyb3I6IHRlY2hFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAgICAgLmZyb20oJ3RlY2huaWNpYW5zJylcclxuICAgICAgICAgICAgLnNlbGVjdCgnKicsIHsgY291bnQ6ICdleGFjdCcsIGhlYWQ6IHRydWUgfSk7XHJcblxyXG4gICAgICAgIC8vIEdldCBwZW5kaW5nIHRlY2huaWNpYW5zXHJcbiAgICAgICAgY29uc3QgeyBjb3VudDogcGVuZGluZ1RlY2huaWNpYW5zLCBlcnJvcjogcGVuZGluZ0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAgICAgICAuZnJvbSgndGVjaG5pY2lhbnMnKVxyXG4gICAgICAgICAgICAuc2VsZWN0KCcqJywgeyBjb3VudDogJ2V4YWN0JywgaGVhZDogdHJ1ZSB9KVxyXG4gICAgICAgICAgICAuZXEoJ2lzX3ZlcmlmaWVkJywgZmFsc2UpO1xyXG5cclxuICAgICAgICAvLyBHZXQgdG90YWwgYm9va2luZ3NcclxuICAgICAgICBjb25zdCB7IGNvdW50OiB0b3RhbEJvb2tpbmdzLCBlcnJvcjogYm9va2luZ3NFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAgICAgLmZyb20oJ2Jvb2tpbmdzJylcclxuICAgICAgICAgICAgLnNlbGVjdCgnKicsIHsgY291bnQ6ICdleGFjdCcsIGhlYWQ6IHRydWUgfSk7XHJcblxyXG4gICAgICAgIGlmICh1c2Vyc0Vycm9yIHx8IHRlY2hFcnJvciB8fCBwZW5kaW5nRXJyb3IgfHwgYm9va2luZ3NFcnJvcikge1xyXG4gICAgICAgICAgICB0aHJvdyB1c2Vyc0Vycm9yIHx8IHRlY2hFcnJvciB8fCBwZW5kaW5nRXJyb3IgfHwgYm9va2luZ3NFcnJvcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHRvdGFsVXNlcnM6IHRvdGFsVXNlcnMgfHwgMCxcclxuICAgICAgICAgICAgdG90YWxUZWNobmljaWFuczogdG90YWxUZWNobmljaWFucyB8fCAwLFxyXG4gICAgICAgICAgICBwZW5kaW5nVGVjaG5pY2lhbnM6IHBlbmRpbmdUZWNobmljaWFucyB8fCAwLFxyXG4gICAgICAgICAgICB0b3RhbEJvb2tpbmdzOiB0b3RhbEJvb2tpbmdzIHx8IDBcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuXHJcbiAgICBhc3luYyB2ZXJpZnlUZWNobmljaWFuKHRlY2huaWNpYW5JZDogc3RyaW5nKSB7XHJcbiAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAgICAgLmZyb20oJ3RlY2huaWNpYW5zJylcclxuICAgICAgICAgICAgLnVwZGF0ZSh7IGlzX3ZlcmlmaWVkOiB0cnVlLCBhdmFpbGFiaWxpdHlfc3RhdHVzOiAnYXZhaWxhYmxlJyB9KVxyXG4gICAgICAgICAgICAuZXEoJ2lkJywgdGVjaG5pY2lhbklkKVxyXG4gICAgICAgICAgICAuc2VsZWN0KClcclxuICAgICAgICAgICAgLnNpbmdsZSgpO1xyXG5cclxuICAgICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xyXG4gICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfVxyXG59O1xyXG4iXSwibmFtZXMiOlsic3VwYWJhc2UiLCJwcm9maWxlU2VydmljZSIsImdldFByb2ZpbGUiLCJ1c2VySWQiLCJkYXRhIiwiZXJyb3IiLCJmcm9tIiwic2VsZWN0IiwiZXEiLCJtYXliZVNpbmdsZSIsInVwZGF0ZVByb2ZpbGUiLCJ1cGRhdGVzIiwidXBkYXRlIiwidXNlciIsImF1dGgiLCJnZXRVc2VyIiwiRXJyb3IiLCJuZXdQcm9maWxlIiwiaW5zZXJ0RXJyb3IiLCJpbnNlcnQiLCJpZCIsImVtYWlsIiwiZnVsbF9uYW1lIiwidXNlcl9tZXRhZGF0YSIsInJvbGUiLCJzaW5nbGUiLCJ1cGRhdGVDdXN0b21lclByb2ZpbGUiLCJjdXN0b21lckRhdGEiLCJwaG9uZSIsImFkZHJlc3MiLCJjaXR5IiwicG9zdGNvZGUiLCJwcmVmZXJyZWRfY29udGFjdCIsInVwZGF0ZWRfYXQiLCJEYXRlIiwidG9JU09TdHJpbmciLCJnZXRUZWNobmljaWFuUHJvZmlsZSIsInByb2ZpbGUiLCJwcm9maWxlcyIsInRlY2hEYXRhIiwiY3JlYXRlVGVjaG5pY2lhblByb2ZpbGUiLCJpbml0aWFsRGF0YSIsImdldFRlY2huaWNpYW5zIiwibGltaXQiLCJxdWVyeSIsIm1hcCIsInRlY2giLCJnZXRQZW5kaW5nVGVjaG5pY2lhbnMiLCJnZXRUZWNobmljaWFuc0J5U2VydmljZSIsInNlcnZpY2VJZCIsInRlY2hTZXJ2aWNlIiwidGVjaG5pY2lhbl9zZXJ2aWNlcyIsInNlcnZpY2VfcHJpY2UiLCJjdXN0b21fcHJpY2UiLCJjYWxjdWxhdGVEaXN0YW5jZSIsImxhdDEiLCJsb24xIiwibGF0MiIsImxvbjIiLCJSIiwiZExhdCIsIk1hdGgiLCJQSSIsImRMb24iLCJhIiwic2luIiwiY29zIiwiYyIsImF0YW4yIiwic3FydCIsImdldFRlY2huaWNpYW5zQnlMb2NhdGlvbiIsImN1c3RvbWVyTGF0IiwiY3VzdG9tZXJMbmciLCJ0ZWNobmljaWFuc1dpdGhEaXN0YW5jZSIsImRpc3RhbmNlIiwibG9jYXRpb25fbGF0IiwibG9jYXRpb25fbG5nIiwicm91bmQiLCJmaWx0ZXIiLCJzZXJ2aWNlX3JhZGl1c19taWxlcyIsInNvcnQiLCJiIiwic2xpY2UiLCJnZXRBbGxVc2VycyIsIm9yZGVyIiwiYXNjZW5kaW5nIiwiZ2V0VXNlclN0YXRzIiwiY291bnQiLCJ0b3RhbFVzZXJzIiwidXNlcnNFcnJvciIsImhlYWQiLCJ0b3RhbFRlY2huaWNpYW5zIiwidGVjaEVycm9yIiwicGVuZGluZ1RlY2huaWNpYW5zIiwicGVuZGluZ0Vycm9yIiwidG90YWxCb29raW5ncyIsImJvb2tpbmdzRXJyb3IiLCJ2ZXJpZnlUZWNobmljaWFuIiwidGVjaG5pY2lhbklkIiwiaXNfdmVyaWZpZWQiLCJhdmFpbGFiaWxpdHlfc3RhdHVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/profileService.ts\n"));

/***/ })

});